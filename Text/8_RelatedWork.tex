\section{Related work} 
\label{sec:Related}
In this section, we discuss work that (1) tackles automated software transplantation and (2) video game content generation.

%\subsection{Automated Software Transplantation}
\noindent \textbf{Automated Software Transplantation}
%On functionality transplantation, 
Miles \etal~\cite{miles2012situ} and Petke \etal~\cite{petke2014using} proposed the first approaches that transplant software code in a same program (assuming that different versions of the programs are considered a same program). 
This seminal work has inspired follow up research to perform Automated Software Transplantation between different programs~\cite{barr2015automated}, or even different programming languages~\cite{marginean2021automated}  and platforms~\cite{kwon2017cpr}, as summarised below.
%When transplanting within a same program, there is no need for adapters (\ie alterations in organ or host to adapt the organ to fit into the host).
Sidiroglou-Douskos \etal~\cite{sidiroglou2015horizontal} proposed a technique that divides the donor program by specific functionality, each piece is called a \sq{shard}. 
%The approach insert the shard into the host without modifications, that is, the work from Sidiroglou-Douskos does not use adapters either.
On the other hand, Maras \etal~\cite{maras2015towards} proposed a three step general approach, without implementing it, which applies feature localization to identify the organ; then code analysis and adaptation, and finally feature integration. Wang \etal~\cite{wang2016hunter} instead of using feature localization, takes as inputs the desired type signature of the organ and a natural language description of its functionality. With that, the approach called Hunter uses any existing code search engine to search for a method to transplant in a database of software repositories. 
%Further, Hunter generates adapter functions to transform the types from the desired type signature into the type signatures of the candidate functions.
Allamanis \etal's SMARTPASTE~\cite{allamanis2017smartpaste} takes the organ and replace variable names with holes, the approach using a deep neural network fills the holes. 
%Allamanis \etal~\cite{allamanis2017smartpaste} use Gated Graph Neural Networks~\cite{li2015gated} to predict the correct variable name in an expression.
Unlike Allamanis \etal, who puts holes into the organ, Lu \etal~\cite{lu2018program} introduced program slicing where the host is provided with a draft of the code with holes, or natural language comments. Similarly to Wang \etal~\cite{wang2016hunter} , program splicing looks into a database of programs to identify a relevant code to the current transplant task. 
%Finally, the approach selects the more suitable result found to fill the holes in the draft.
Barr \etal propose $\mu$SCALPEL~\cite{barr2015automated}, an automatic code transplant tool that uses genetic programming and testing to transplant code from one program to another. 
$\mu$SCALPEL uses test cases to define and maintain functionalities, small changes are made to the transplanted code, and code that does not aid in passing tests can be discarded, reducing the code to its minimal functioning form. 
Subsequently, Marginean \etal proposes $\tau$SCALPEL~\cite{marginean2021automated} to achieve the transplantation between different programs and programming languages. 
Kwon \etal propose CPR~\cite{kwon2017cpr} that transplants an entire program between different platforms. CPR realizes software transplantation by synthesizing a platform independent program from a platform dependent program. 
%To synthesis the platform independent program, CPR uses PIEtrace~\cite{kwon2013pietrace} to construct a set of trace programs, which captures the control flow path and the data dependencies observed during a concrete execution, and replaces all the platform dependencies with the concrete values that it observed during the concrete execution. Finally, CPR merges all these trace programs together to handle any input, by replacing the concrete values observed during the executions, with input variables. 
To the best of our knowledge our is the first proposal addressing automated software transplantation in the field of content generation for video games. Our proposal allows the transplantation between different types of content. We have demonstrated that in this context a simulation-based objective function yield superior outcomes compared to the test-based objective function that previously attained the most favourable results in traditional software engineering transplantation ($\mu$SCALPEL~\cite{marginean2021automated}).

%\subsection{Procedural Content Generation}
\noindent \textbf{Procedural Content Generation}
%Procedural Content Generation (PCG) refers to the automation or semi-automation of the generation of content in video games~\cite{hendrikx2013procedural}. The types of content generated by PCG are diverse, such as vegetation~\cite{mora2021flora}, sound~\cite{plans2012experience}, terrain~\cite{frade2009breeding}, Non-Playable Characters~\cite{viana2022illuminating}, dungeons~\cite{viana2019survey}, puzzles~\cite{de2019procedural}, and even the rules of a game~\cite{browne2008automatic}. PCG is a large field spanning many algorithms~\cite{yannakakis2018artificial}, which can be grouped in three main categories according to the survey of PCG techniques by Barriga et al.~\cite{Barriga2019}: Traditional methods~\cite{freiknecht2017survey} that generate content under a procedure without evaluation; Machine Learning methods (PCGML)~\cite{Summerville2018,liu2021deep,souchleris2023reinforcement} that train models to generate new content; and Search-Based methods (SBPCG)~\cite{hendrikx2013procedural,togelius2011search} that generate content through a search on a predefined space guided by a meta-heuristic using one or more objective functions. 
PCG refers to the automation or semi-automation of the generation of content in video games~\cite{hendrikx2013procedural}. %The types of content generated by PCG are diverse, such as vegetation~\cite{mora2021flora}, sound~\cite{plans2012experience}, terrain~\cite{frade2009breeding}, Non-Playable Characters~\cite{viana2022illuminating} or even the rules of a game~\cite{browne2008automatic}. 
PCG is a large field spanning many algorithms~\cite{yannakakis2018artificial}, which can be grouped in three main categories~\cite{Barriga2019}: Traditional methods~\cite{freiknecht2017survey} generating content under a procedure without evaluation; Machine Learning methods (PCGML)~\cite{Summerville2018,liu2021deep,souchleris2023reinforcement} that train models to generate new content; and Search-Based methods (SBPCG)~\cite{hendrikx2013procedural,togelius2011search} that generate content through a search on a predefined space guided by a meta-heuristic using one or more objective functions. 
%An interesting aspect of SBPCG is the objective function (or fitness function) that guides the search towards an optimal solution. SBPCG differentiates between three different types~\cite{togelius2011search}: direct, simulation, and interactive. Direct objective functions are those that are based on the available knowledge of developers (that is, the developers themselves participate in the assessment of the objective function). Direct objective functions can be either theory-driven (meaning that the opinion of the developers is directly leveraged) or data-driven (meaning that information about relevant parameters is extracted from artefacts like questionnaires or player models). Simulation objective functions replicate real situations to estimate the behaviour of real players. Work in this area focuses mainly on developing more human-like agents, bots, and AIs to be used as objective functions. Simulation objective functions can be static, where the simulator agent does not change during the simulation, or dynamic, where agents that learn during simulation are used. Finally, interactive objective functions are those that involve players in the composition of the objective function.In SBPCG, interactive objective functions can be either explicit, when players are outright asked for their opinions, or implicit, when the data is indirectly extracted or inferred from the observation of the actions of the players and the results of those actions.
Our work falls in the SBPCG category and it generates content of the NPC type. In the context of NPC generation using SBPCG, Ripamonti \etal~\cite{ripamonti2021dragon} developed a novel approach to generate monsters adapted to players, considering the monster with more death rate the preferred by the player. To evaluate the monsters, they recreated an environment with the main aspects from a MMORPG~\footnote{Massive Multiplayer Online Role-Playing Games} game. Pereira \etal~\cite{pereira2021procedural_enemies} and later extended by Viana \etal~\cite{viana2022illuminating} seek for generating enemies that meet a difficulty criteria. Pereira \etal and Viana \etal use the same research academic game in their experimental designs. Blasco \etal~\cite{blasco2021evolutionary} focusses on generating spaceship enemies that are comparable to the ones manually created by developers. To generate spaceships, Gallota \etal~\cite{gallotta2022evolving} used a combination of Lindenmayer systems~\cite{lindenmayer1968mathematical} and evolutionary algorithm. Gallota \etal as well as Blasco \etal use a commercial video game in their evaluation.
In the context of ML, to the best of our knowledge there is a gap in the generation of NPC. ML research focus on other aspects of video games, such AI~\cite{brocchini2022monster} or graphical aesthetics~\cite{li2020automatic}.
The motivation of our work comes from the limitations that we detected in previous work. Previous work focused on speeding up development time. However, the influence of the developers on the generated content was limited. The generated content depended on randomness resulting on generated content not aligned with the intention of the developers. As a result, the generated content was either not used or used as secondary content. 
Our work is the first approach that tackles automated software transplantation if the field of video games. Furthermore, our proposal allows the transplantation between different types of content. More precisely, in this work, we transplant organs from a scenarios to NPCs.

%Our previous work also generates NPCs using SBSE~\cite{blasco2021evolutionary}. Our previous work focused on using search to speed up development time. However, in our previous work the influence of the developers on the generated content was limited. The generated NPC depended on randomness resulting on generated NPCs not aligned with the intention of the developers. As a result, the generated content was either not used or used as secondary content. In fact, the limitations of our previous work were the inspiration for moving to transplantation. The transplant-based approach of this work keeps control in the hands of the developers (who choose the organ to transplant) and helps to explore the latent content that exists in the video game.

%, our approach transplant scenario elements into a NPC to obtain a novel version of the NPC. From the best of our knowledge we are the first work applying transplantation in PCG. Guarneri \etal~\cite{guarneri2013golem} or Norton \etal~\cite{norton2017monsters}  generate NPC monsters through an evolutionary algorithm with the aim of obtaining a diversity set of new monsters. With the same goal, 

%Our research introduces a fresh perspective on content generation through the use of transplantation, which sets it apart from traditional procedural content generation (PCG) methods. Transplantation enables the seamless integration of various content types, facilitating in our work the transplant of elements from scenarios to NPCs.

% \subsection{MDE and Game Software Engineering}

% One of the challenges in software development is the environment used, as each environment and programming languages has unique characteristics. Software models, and more precisely Model Driven Engineering, study how to alleviate this problem by approaching software development from a platform-independent perspective through models. Video game developers must deal with this challenge as well and has motivated the research that combine software models and the domain of video games. 

% The 2010 survey of Software Engineering Research for Computer Games~\cite{ampatzoglou2010software} identified only one work that applied Model-Driven Development to video games~\cite{reyno2009automatic}. That work coined the term ‘‘Model-Driven Game Development’’ and presented a first approach to 2D game prototyping through Model-Driven Development. Specifically, they used UML classes and state diagrams that were extended with stereotypes, and a model-to-code transformation to generate C++ code.

% More recent work presents work that intended to minimize errors, time, and cost in multi-platform video game development and maintenance~\cite{Nunez17,Nunez13,Usman17}, or suggest the use of business process models as the modelling language for video games~\cite{Solis15}.

% In the intersection between software models and evolutionary computation, Williams \etal~\cite{Williams11} use an evolutionary algorithm to search for desirable game character behaviours in a text-based video game that plays unattended combats and that outputs an outcome result. The character behaviour is defined using a Domain-Specific Language. The combats are managed internally and are only driven by behaviour parameters, without taking into account a spatial environment, real-time representation, or visual feedback (which takes into consideration the physical interaction of the characters, variation in the properties, etc.).

% Another work that focuses on the intersection between software models and evolutionary computation is Avida-MDE~\cite{Goldsby2008}, which generates state machines that describe the behaviour of one of the classes of a software system (Adaptive Flood Warning System case study). The resulting state machines comply with developer requirements (scenarios for
% adaptation). Instead of generating whole models, Avida-MDE extends already existing models (object models and state machines) with new state machines that support new scenarios. The work in Goldsby and Cheng \etal~\cite{Goldsby2008} does not report the size of the generated state machines; however, the ones shown in the paper are around 50 model elements, which is significantly smaller than the more than 1000 model elements of the models of a commercial video game such as Kromaia.

% The work mentioned above focus on generating new content from models, which differs with our proposal of using MDE to transplant model fragments between models.

% \subsection{Conclusion}

% Our work differs from previous work for various aspects. 
% To the best of our knowledge our is the first paper addressing automated software transplantation if the field of video games. Our proposal allows the transplantation between different types of content. More precisely, we transplant elements from a scenario to an NPC. The use of MDE separate the problem from the platform, and even the specific video game, as a same Domain Specific Language can be used in different video games.