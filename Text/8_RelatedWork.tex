\section{Related work} \label{sec:Related}

This work generates original content in video games leveraging software transplantation. In this section, we discuss: (1) work that tackles automated software transplantation; and (2) work that tackles video game content generation.

\subsection{Automated Software Transplantation}

On functionality transplantation, Miles \etal~\cite{miles2012situ} and Petke \etal~\cite{petke2014using} proposed the first approaches that transplant software code in a same program (assuming that different versions of the programs are considered a same program). When transplanting within the same program, there is no need for adapters, alterations in organ or host to adapt the organ in the host. Sidiroglou-Douskos \etal~\cite{sidiroglou2015horizontal} proposed a technique that divides the donor program by specific functionality, each piece is called a \sq{shard}. The approach insert the shard into the host without modifications, that is, the work from Sidiroglou-Douskos does not use adapters either.

On the other hand, Maras \etal~\cite{maras2015towards} proposed a three step general approach, without implementing it, which applies feature localization to identify the organ; then code analysis and adaptation, and finally feature integration. Wang \etal~\cite{wang2016hunter} instead of using feature localization, takes as inputs the desired type signature of the organ and a natural language description of its functionality. With that, the approach called Hunter uses any existing code search engine to search for a method to transplant in a database of software repositories. Further, Hunter generates adapter functions to transform the types from the desired type signature into the type signatures of the candidate functions.

Allamanis \etal's SMARTPASTE~\cite{allamanis2017smartpaste} presents a different strategy to adapt the organ into the host. SMARTPASTE takes the organ and replace variable names with holes, the approach using a deep neural network fills the holes. Allamanis \etal~\cite{allamanis2017smartpaste} use Gated Graph Neural Networks~\cite{li2015gated} to predict the correct variable name in an expression.

In 2018, Lu \etal~\cite{lu2018program} introduced program splicing, a framework to automate the process of copy, paste, and organ modification. In their approach, unlike Allamanis \etal, who puts holes into the organ, the host is provided with a draft of the code with holes, or natural language comments. Similarily to, Wang \etal, program splicing looks into a database of programs to identify a relevant code to the current transplant task. Finally, the approach selects the more suitable result found to fill the holes in the draft.

$\mu$SCALPEL~\cite{barr2015automated} is an automatic code transplant tool that uses genetic programming and testing to transplant code from one program to another. $\mu$SCALPEL uses test cases to define and maintain functionalities, small changes are made to the transplanted code, and code that does not aid in passing tests can be discarded, reducing the code to its minimal functioning form. $\tau$SCALPEL~\cite{marginean2021automated} achieves the transplantation between different programs and programming languages. 

We have seen so far that Automated Software Transplantation transplants within the same platform. However, Kwon \etal propose CPR~\cite{kwon2017cpr} that transplants an entire program between different platforms. CPR realizes software transplantation by synthesizing a platform independent program from a platform dependent program. To synthesis the platform independent program, CPR uses PIEtrace~\cite{kwon2013pietrace} to construct a set of trace programs, which captures the control flow path and the data dependencies observed during a concrete execution, and replaces all the platform dependencies with the concrete values that it observed during the concrete execution. Finally, CPR merges all these trace programs together to handle any input, by replacing the concrete values observed during the executions, with input variables. 

To the best of our knowledge our is the first proposal addressing automated software transplantation in the field of content generation for video games. Our proposal allows the transplantation between different types of content. We have demonstrated that in this context the simulations yield superior outcomes compared to the test-based objective function that previously attained the most favourable results ($\mu$SCALPEL).

\subsection{Procedural Content Generation}

Procedural Content Generation (PCG) refers to the automation or semi-automation of the generation of content in video games~\cite{hendrikx2013procedural}.  The types of content generated by PCG are diverse, such as vegetation~\cite{mora2021flora}, sound~\cite{plans2012experience}, terrain~\cite{frade2009breeding}, Non-Playable Characters (NPCs)~\cite{viana2022illuminating}, dungeons~\cite{viana2019survey}, puzzles~\cite{de2019procedural}, and even the rules of a game~\cite{browne2008automatic}.PCG is a large field spanning many algorithms~\cite{yannakakis2018artificial}, which can be grouped in three main categories according to the survey of PCG techniques by Barriga et al.~\cite{Barriga2019}: Traditional methods~\cite{freiknecht2017survey} that generate content under a procedure without evaluation; Machine Learning methods (PCGML)~\cite{Summerville2018,liu2021deep,souchleris2023reinforcement} that train models to generate new content; and Search-Based methods (SBPCG)~\cite{hendrikx2013procedural,togelius2011search} that generate content through a search on a predefined space guided by a meta-heuristic using one or more objective functions. 

An interesting aspect of SBPCG is the objective function (or fitness function) that guides the search towards an optimal solution. SBPCG differentiates between three different types~\cite{togelius2011search}: direct, simulation, and interactive. Direct objective functions are those that are based on the available knowledge of developers (that is, the developers themselves participate in the assessment of the objective function). Direct objective functions can be either theory-driven (meaning that the opinion of the developers is directly leveraged) or data-driven (meaning that information about relevant parameters is extracted from artefacts like questionnaires or player models). Simulation objective functions replicate real situations to estimate the behaviour of real players. Work in this area focuses mainly on developing more human-like agents, bots, and AIs to be used as objective functions. Simulation objective functions can be static, where the simulator agent does not change during the simulation, or dynamic, where agents that learn during simulation are used. Finally, interactive objective functions are those that involve players in the composition of the objective function.
In SBPCG, interactive objective functions can be either explicit, when players are outright asked for their opinions, or implicit, when the data is indirectly extracted or inferred from the observation of the actions of the players and the results of those actions.

Our work is positioned within SBPCG in the NPCs category, our approach transplant scenario elements into a NPC to obtain a novel version of the NPC. From the best of our knowledge we are the first work applying transplantation in PCG. Guarneri \etal~\cite{guarneri2013golem} or Norton \etal~\cite{norton2017monsters}  generate NPC monsters through an evolutionary algorithm with the aim of obtaining a diversity set of new monsters. With the same goal, Ripamonti \etal~\cite{ripamonti2021dragon} developed a novel approach to generate monsters adapted to players, considering the monster with more death rate the preferred by the player.
Pereira \etal~\cite{pereira2021procedural_enemies} and later extended by Viana \etal~\cite{viana2022illuminating} instead of diversity seek for generating enemies that meet a difficulty criteria.

Our work uses the same case study as Blasco \etal~\cite{blasco2021evolutionary} who generate spaceship enemies which quality is comparable to manually content created by developers. Their approach also works software models as we do, instead of code. On other hand, to generate also spaceships, Gallota \etal~\cite{gallotta2022evolving} used a combination of Lindenmayer systems~\cite{lindenmayer1968mathematical} and evolutionary algorithm.

Our research introduces a fresh perspective on content generation through the use of transplantation, which sets it apart from traditional procedural content generation (PCG) methods. Transplantation enables the seamless integration of various content types, facilitating in our work the transplant of elements from scenarios to NPCs.

% \subsection{MDE and Game Software Engineering}

% One of the challenges in software development is the environment used, as each environment and programming languages has unique characteristics. Software models, and more precisely Model Driven Engineering, study how to alleviate this problem by approaching software development from a platform-independent perspective through models. Video game developers must deal with this challenge as well and has motivated the research that combine software models and the domain of video games. 

% The 2010 survey of Software Engineering Research for Computer Games~\cite{ampatzoglou2010software} identified only one work that applied Model-Driven Development to video games~\cite{reyno2009automatic}. That work coined the term ‘‘Model-Driven Game Development’’ and presented a first approach to 2D game prototyping through Model-Driven Development. Specifically, they used UML classes and state diagrams that were extended with stereotypes, and a model-to-code transformation to generate C++ code.

% More recent work presents work that intended to minimize errors, time, and cost in multi-platform video game development and maintenance~\cite{Nunez17,Nunez13,Usman17}, or suggest the use of business process models as the modelling language for video games~\cite{Solis15}.

% In the intersection between software models and evolutionary computation, Williams \etal~\cite{Williams11} use an evolutionary algorithm to search for desirable game character behaviours in a text-based video game that plays unattended combats and that outputs an outcome result. The character behaviour is defined using a Domain-Specific Language. The combats are managed internally and are only driven by behaviour parameters, without taking into account a spatial environment, real-time representation, or visual feedback (which takes into consideration the physical interaction of the characters, variation in the properties, etc.).

% Another work that focuses on the intersection between software models and evolutionary computation is Avida-MDE~\cite{Goldsby2008}, which generates state machines that describe the behaviour of one of the classes of a software system (Adaptive Flood Warning System case study). The resulting state machines comply with developer requirements (scenarios for
% adaptation). Instead of generating whole models, Avida-MDE extends already existing models (object models and state machines) with new state machines that support new scenarios. The work in Goldsby and Cheng \etal~\cite{Goldsby2008} does not report the size of the generated state machines; however, the ones shown in the paper are around 50 model elements, which is significantly smaller than the more than 1000 model elements of the models of a commercial video game such as Kromaia.

% The work mentioned above focus on generating new content from models, which differs with our proposal of using MDE to transplant model fragments between models.

% \subsection{Conclusion}

% Our work differs from previous work for various aspects. 
% To the best of our knowledge our is the first paper addressing automated software transplantation if the field of video games. Our proposal allows the transplantation between different types of content. More precisely, we transplant elements from a scenario to an NPC. The use of MDE separate the problem from the platform, and even the specific video game, as a same Domain Specific Language can be used in different video games.