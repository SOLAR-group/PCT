\section{Introduction}
\label{sec:intro}

%\IEEEPARstart{T}{he} 

The video games industry grows significantly every year~\cite{rykala2020growth}. In 2019, it became the largest entertainment industry in terms of revenue after surpassing the combined revenues of the movie and music industries~\cite{politowski2021game}. In 2021, video games generated revenues of \$180.3 billion~\cite{wijman2021games}, and in 2022, the estimated revenues were of \$184.4 billion~\cite{wijman2022games}. Overall, the sum of revenues generated from 2020 to 2022 was almost \$43 billion higher than those originally forecasted for the period. 

%In 2019, out of a total population of 18.9M software developers, 8.8M developers were involved in video games development at some point~\cite{devData}, and by the end of 2022~\cite{devNation}, those who self-identified as software developers accounted for 24\% of all professional video game developers, which is a higher percentage than those who self-identified as game designers (23\%), artists (15\%), UI designers (8\%), or QA engineers (5\%) - roles that are typically identified by consumers as core roles for video games development.

Video games are complex creations where art and software go hand in hand during the development process to conform the final product. Hence, development teams are conformed by different profiles, where the majority are software developers (24\%), but also include game designers (23\%), artists (15\%), UI designers (8\%), and QA engineers (5\%), based on a recent survey with professional game developers~\cite{devNation}. In a video game, software permeates every aspect of the development, since it governs all the elements and actions that can appear or happen within the game. For instance, software controls the logic behind the actions of NPCs\footnote{Non-playable characters.} within a game (often through state machines or decision trees). As video games become more and more advanced, their software also becomes more complex.

To alleviate the complexity of video game development, most video games are developed using game engines. The most popular video game engines are Unity~\footnote{\url{https://unity.com/}} and Unreal~\footnote{\url{https://www.unrealengine.com/}}. Game engines are development environments that integrate a graphics engine and a physics engine, as well as tools to accelerate development. For example, they provide a ready-to-use implementation of gravity or collisions between elements. Game engines significantly speed up the development of video games. However, for game developers, the main challenge is to develop the game content. Game content includes from game scenarios to NPCs or game items such as weapons.

% --- PHARAGRAPH TO MOVE --- 
%Software for video games can be implemented either through code or through software models. Developing a game through code enhances the control that developers have over the game. The downside to developing games through code is dealing with the implementation details. On the other hand, models elevate the abstraction level using domain concepts that are closer to its developers. Developing a game through modeling relieves the developers from the implementation details, and allows non-technical roles (such as level designers and artists) to participate in key aspects of the development. This competitive advantage over traditional code is a potential reason behind the recent increase in the popularity of modeling for developing video games: one of the most widespread video game development engines (Unreal Engine provides a proprietary modeling language for development (Unreal Blueprints), and a recent survey in Model-Driven Game Development~\cite{zhu2019model} reveals that both UML and Domain Specific Language (DSL) models are also being adopted by development teams. The benefits of modeling present an opportunity for video game development teams to better cope with the growing complexity and demands of the software behind the games.

%The systematic reuse of previously generated content, or parts of it, in order to minimize bugs and cut development times is a very common occurrence within the video games industry~\cite{neto2009reuse}. However, manual reuse of content is typically frowned upon by the players: since developers tend to look at the components that they are most knowledgeable about for reuse, new content that is created from existing content tends to feel repetitive, unoriginal, and low-effort. This is especially true for video game content that has associated visual components (e.g. moving parts with reused animations).

%One of such demands is the demand for content. With every passing day, the demand for video games content keeps growing, with players requesting - and more often than not, expecting - more content than developers can produce. 
Content generation is generally a slow, tedious, costly, and error-prone manual process. To cope with the growing demand for content for video games, researchers have been working towards Procedural Content Generation (PCG). PCG refers to the field of knowledge that aims at the (semi) automatic generation of new content within video games~\cite{hendrikx2013procedural}. Current PCG approaches work as follows: Developers provide initial content (usually human-generated content) into an algorithm. Afterwards, the algorithm (Traditional, Machine Learning, or Search-Based methods) will generate new content. This far only a few traditional methods have succeeded in providing tools used by the industry to randomly generate vegetation (e.g., SpeedTree~\footnote{\url{https://store.speedtree.com}} in Unreal and Unity).

In this paper, we propose a new angle to tackle PCG for video games inspired by transplantation techniques~\cite{barr2015automated}, which we named Procedural Content Transplantation (PCT). In medicine, \textit{transplantation} is a procedure in which cells, tissues, or organs of an individual are replaced by those of another individual, or the same person~\cite{FARSHBAFNADI2023599}. In software, researchers understand transplantation as a procedure in which a fragment (organ) of a software element (donor) is transferred into another software element (host)~\cite{barr2015automated}. Software transplantation has been successful for different tasks: program repair~\cite{weimer2009automatically,sidiroglou2014automatic}, testing~\cite{zhang2017automated}, security~\cite{yang2017malware}, and functionality improvements~\cite{sidiroglou2017codecarboncopy}.

%Current PCG approaches work as follows: developers provide initial content (usually human-generated content) into an algorithm to work with. Afterwards, the algorithm (Traditional, Machine Learning, or Search-Based methods) will generate new content. Only a few traditional methods have succeeded in providing tools used by the industry to randomly generate vegetation (e.g., SpeedTree in Unreal and Unity). 
Our PCT proposal introduces for the first time the transplantation metaphor into PCG. In our approach, the developers of a game will select an organ (a fragment of video game content) from a donor (video game content) and a host (another video game content) that will receive the organ. The organ and the host will serve as inputs for our transplantation algorithm that will generate new content for the game by automatically combining the organ and the host. Our hypothesis is that our transplantation approach can release latent content that results from combining fragments of existing content. Furthermore, our transplantation approach provides more control to developers in comparison to current industrial approaches that are based on random generation, leading to results that are closer to developers' expectations.

%Our PCT algorithm works with Search-Based Software Engineering. Search-Based Software Engineering has a better shot at exploring large search spaces than humans. In the state-of-the-art of software transplantation, the search evolves through genetic operations (crossover and mutation) and is guided by a test objective function. In the field of Search-Based Procedural Content Generation (SBPCG), the common practice is to guide the search through a simulation objective function. Taking into account the differences between both fields of research, we chose to leverage tests and simulations separately to guide the transplantation algorithm, and then compare the results obtained by the two objective functions.

%Another difference between the state-of-the-art of software transplantation and SBPCG is the representation of the problem. Software transplantation works directly over the source code of a program, whereas due to the nature of video games, in SBPCG it is common to use software models to represent the content (more specifically, the links between the elements that conform the content) within the game. Since our approach aims to solve a problem in the field of SBPCG, we use software models for our representation.

Our approach, called \ApproachName{}\footnote{Our approach is named after \ApproachName{}, who is considered by many to have written the Edwin Smith Papyrus (the oldest known manual of surgery).}, relies on Search-based Software Engineering (SBSE) because SBSE has demonstrated success in software transplantation~\cite{barr2015automated}. In the literature, software transplantation approaches guide the search by using test-suites, \ie, the transplantation assessment is determined by the amount of tests that a candidate solution is able to pass. Our work not only explores the use of test-suite (\timhotep{}) but also the use of video game simulations (\simhotep{}) to guide the search.  Our hypothesis is that it is possible to harness video games' NPCs to run simulations that provide data to asses the transplantations. Within video games, it is typical to find NPCs that serve as companions to the player, adversaries to defeat, or inhabitants of the virtual world. These NPCs have pre-programmed behaviours that could be used in game simulations. For instance, in a first-person shooter game (like the renowned Doom video game), NPCs explore the game scenarios in search of weapons and power-ups to engage in combat with other NPCs or the player.

We have evaluated our proposal over the \CaseStudy{} case study. \CaseStudy{} is a commercial video game about flying and shooting with a spaceship in a three-dimensional space\footnote{See the official PlayStation trailer to learn more about \CaseStudy{}: \url{https://youtu.be/EhsejJBp8Go}}. The game has been released on PC, PlayStation, and translated to eight different languages.
To evaluate \ApproachName{}, we transplant 129 different organs extracted from the scenarios of \CaseStudy{} into 5 of the video game bosses that act as hosts, generating new video game bosses. 
In total, our approach analysed 645 transplants. To the best of our knowledge, our work has more transplants than previous work in the literature, which achieved a maximum of 327 successful transplants~\cite{reid2020optimising}. 
%We assess the quality of each generated boss by computing the duration of a match between the generated boss and a simulated player, a measurement that stems from the literature~\cite{browne2010evolutionary}. 

We compare the results of the two \ApproachName{} variants (\timhotep{} and \simhotep{}) to the PCG baseline from the literature~\cite{gallotta2022evolving}. To make the comparison, we rely on the concept of game quality and its automated measurement, which is widely accepted in practice~\cite{browne2010evolutionary}. 

The results show that, out of the three approaches (the two \ApproachName{} variants and the baseline), the content generated through the \simhotep{} variant obtains the best results. This approach yields 1.5x better results than \timhotep{} and 2.5x better results than baseline. The statistical analysis shows that the differences are significant, and the magnitude of improvement is large.

To the best of our knowledge, this is the first work that leverages transplantation to generate video game content, obtaining more favourable solutions than the baseline in an industrial setting. Specifically, we claim that:

\begin{itemize}
    
    \item The results show that PCG through transplants is not only feasible, but desirable. Our approach has significantly outperformed classic content generation in the evaluation of this work, opening a new road towards tackling the pressing problem that the industry has with excessive delays in content creation (with notorious examples in Cyberpunk 2077~\cite{cyberpunk2077} or GTA VI~\cite{gta6}) and with the ever-increasing demand for game content derived from post-launch updates, Downloadable Content (DLCs), games as a service, or platform-exclusive content.
    
    \item To this date, this is the transplantation work with the most successful transplants - almost double than its pursuer. Moreover, the transplants are carried out in an real-world industrial context in contras to the academic context of the pursuer.
    
    \item Our work returns control to the hands of the developers through organ selection. In comparison, the most successful industrial approaches (such as SpeedTree) lie on chance. The generated content is hence more in line with the intent of developers, as discussed in the focus group. This is key towards the real-world industrial usage of the generated automatically content.
    
    \item Our work reveals that harnessing simulations rather than test suites leads to significantly better results. This may empower software transplantation researchers to reconsider the usage of test suites in their work. Additionally, the upgrowth of digital twins encourages studying simulation-guided transplants in other domains beyond video games.

    \item Our analysis of the results reveals interactions between organs that have not been identified previously in the literature. These interactions are a promising line of research to advance the field of software transplants.
    
    \item Finally, this work is also relevant towards raising awareness for the need of research in the software part of video games. Despite the importance of software for video games, and the increase in the relevance of video games themselves in our society, video games remain as a relatively unexplored topic that has not received much attention from the software engineering research community.
    
\end{itemize}

The rest of the paper is structured as follows: Section~\ref{sec:Background} provides some background to better understand our work. Section~\ref{sec:Approach} describes our approach, depicting its usage for PCG. Section~\ref{sec:Evaluation} details the evaluation of our approach. Section~\ref{sec:Results} highlights the results of our research. Section~\ref{sec:Discussion} discusses the outcomes of the paper and future lines of work. Section~\ref{sec:Threats} outlines the threats to the validity of our work. Section~\ref{sec:Related} reviews the works related to this one. Finally, 
Section~\ref{sec:Conclusion} concludes the paper by summarizing the main contributions and results.