\section{Introduction}

\IEEEPARstart{T}{he} video games industry grows significantly every year~\cite{rykala2020growth}. In 2019, the video games industry became the largest entertainment industry in terms of revenue after surpassing the combined revenues of the movie and music industries~\cite{politowski2021game}. In 2021, video games generated revenues of \$180.3 billion~\cite{wijman2021games}, and in 2022, the estimated revenues were of \$184.4 billion~\cite{wijman2022games}. Overall, the sum of revenues generated from 2020 to 2022 was almost \$43 billion higher than originally forecasted for the period. 
%In 2019, out of a total population of 18.9M software developers, 8.8M developers were involved in video games development at some point~\cite{devData}, and by the end of 2022~\cite{devNation}, those who self-identified as software developers accounted for 24\% of all professional video game developers, which is a higher percentage than those who self-identified as game designers (23\%), artists (15\%), UI designers (8\%), or QA engineers (5\%) - roles that are typically identified by consumers as core roles for video games development.

Video games are complex creations where art and software go hand in hand during the development process to conform the final product. Hence, development teams are conformed by different profiles, where the majority are software developers (24\%), but also include game designers (23\%), artists (15\%), UI designers (8\%), and QA engineers (5\%), based on a recent survey with professional game developers~\cite{devNation}. In a video game, software often permeates every aspect of the development, since it governs all the elements and actions that can appear or happen within the game. For instance, software controls the logic behind the actions of NPCs\footnote{Non-playable characters which are not controlled by a player} within the game (often through state machines or decision trees). As video games become more and more advanced, their software also becomes more complex.

To alleviate the complexity of video game development, most video games are developed using game engines. The most popular video game engines are Unity~\footnote{\url{https://unity.com/}} and Unreal~\footnote{https://www.unrealengine.com/}). Game engines are development environments that integrate a graphics engine and a physics engine as well as tools to accelerate development. For example, they provide a ready-to-use implementation of gravity or collisions between elements. Game engines significantly speed up the development of video games. For game developers, the main challenge is to develop the game content. Game content includes from the levels to the NPCs or game items such as weapons and power ups.

% --- PHARAGRAPH TO MOVE --- 
%Software for video games can be implemented either through code or through software models. Developing a game through code enhances the control that developers have over the game. The downside to developing games through code is dealing with the implementation details. On the other hand, models elevate the abstraction level using domain concepts that are closer to its developers. Developing a game through modeling relieves the developers from the implementation details, and allows non-technical roles (such as level designers and artists) to participate in key aspects of the development. This competitive advantage over traditional code is a potential reason behind the recent increase in the popularity of modeling for developing video games: one of the most widespread video game development engines (Unreal Engine provides a proprietary modeling language for development (Unreal Blueprints), and a recent survey in Model-Driven Game Development~\cite{zhu2019model} reveals that both UML and Domain Specific Language (DSL) models are also being adopted by development teams. The benefits of modeling present an opportunity for video game development teams to better cope with the growing complexity and demands of the software behind the games.

%The systematic reuse of previously generated content, or parts of it, in order to minimize bugs and cut development times is a very common occurrence within the video games industry~\cite{neto2009reuse}. However, manual reuse of content is typically frowned upon by the players: since developers tend to look at the components that they are most knowledgeable about for reuse, new content that is created from existing content tends to feel repetitive, unoriginal, and low-effort. This is especially true for video game content that has associated visual components (e.g. moving parts with reused animations).

%One of such demands is the demand for content. With every passing day, the demand for video games content keeps growing, with players requesting - and more often than not, expecting - more content than developers can produce. 
Content generation is a generally slow, tedious, costly, and error-prone manual process. In order to cope with the growing demand for content for video games, researchers are working towards Procedural Content Generation (PCG). PCG refers to the field of knowledge that aims at the (semi) automatic generation of new content within video games~\cite{hendrikx2013procedural}. Usually, current PCG approaches work as follows: developers provide initial content (usually human-generated content) into an algorithm to work with. Afterwards, the algorithm (Traditional, Machine Learning, or Search-Based methods) will generate new content. Only a few traditional methods have succeeded in providing tools used by the industry to randomly generate vegetation (e.g., SpeedTree in Unreal and Unity).

In this paper, we propose a new angle to tackle PCG for video games inspired by transplantation techniques~\cite{barr2015automated}, that we named Procedural Content Transplantation (PCT). In medicine, \textit{transplantation} is a procedure in which cells, tissues, or organs of an individual are replaced by those of another individual or the same person~\cite{FARSHBAFNADI2023599}. In software, researchers understand transplantation as a procedure in which a fragment (organ) of a software element (donor) is transferred into another software element (host)~\cite{barr2015automated}. Software transplantation has achieved success on different tasks: program repair~\cite{weimer2009automatically,sidiroglou2014automatic}, testing~\cite{zhang2017automated}, security~\cite{yang2017malware}, or functionality improvements~\cite{sidiroglou2017codecarboncopy}.

%Current PCG approaches work as follows: developers provide initial content (usually human-generated content) into an algorithm to work with. Afterwards, the algorithm (Traditional, Machine Learning, or Search-Based methods) will generate new content. Only a few traditional methods have succeeded in providing tools used by the industry to randomly generate vegetation (e.g., SpeedTree in Unreal and Unity). 
Our PCT proposal introduces the transplantation metaphor into PCG. In our approach, the developers of a game will select an organ (a fragment of video game content) from a donor (video game content) and a host (other video game content) that will receive the organ. The organ and the host will serve as inputs for our transplantation algorithm that will generate new content for the game combining the organ and the host. Our hypothesis is that our transplantation approach can release latent content that results of combining fragments of existing content. Furthermore, our transplantation approach provides more control to developers in comparison to industry approaches that are based on random generation, leading to results that are closer to developers' expectations.

%Our PCT algorithm works with Search-Based Software Engineering. Search-Based Software Engineering has a better shot at exploring large search spaces than humans. In the state-of-the-art of software transplantation, the search evolves through genetic operations (crossover and mutation) and is guided by a test objective function. In the field of Search-Based Procedural Content Generation (SBPCG), the common practice is to guide the search through a simulation objective function. Taking into account the differences between both fields of research, we chose to leverage tests and simulations separately to guide the transplantation algorithm, and then compare the results obtained by the two objective functions.

%Another difference between the state-of-the-art of software transplantation and SBPCG is the representation of the problem. Software transplantation works directly over the source code of a program, whereas due to the nature of video games, in SBPCG it is common to use software models to represent the content (more specifically, the links between the elements that conform the content) within the game. Since our approach aims to solve a problem in the field of SBPCG, we use software models for our representation.

Our approach, called Imhotep\footnote{Our approach is named after Imhotep, who is considered by many to have written the Edwin Smith Papyrus (the oldest known manual of surgery).}, relies on Search-based Software Engineering (SBSE) because SBSE has demonstrated success on software transplantation~\cite{barr2015automated}. In the literature, software transplantation approaches guide the search by Test-suites. The transplantation assessment is determined by the amount of test that a candidate solution is able to pass. Our work not only explores the use of Test-suite (Test-based Imhotep variant) but also we explore the use of video game simulations (Simulation-based Imhotep variant), to guide the search.  Our hypothesis is that it is possible to harness video games' NPCs to run simulations that provide data to asses the transplantations. Within video games, it is typical the find NPCs that serve as companions to the player, adversaries to defeat, or inhabitants of the virtual world. These NPCs have pre-programmed behaviours that could be used in game simulations. For instance, in a first-person shooter game (like the renowned Doom), NPCs explore the game levels in search of weapons and power-ups to engage in combat with other NPCs or the player.

We have carried out our evaluation over the \CaseStudy{} case study. \CaseStudy{} is a video game about flying and shooting with a spaceship in a three-dimensional space\footnote{See the official PlayStation trailer to learn more about \CaseStudy{}: \url{https://youtu.be/EhsejJBp8Go}}. The game was released on PC, PlayStation, and translated to eight different languages.
To evaluate Imhotep, 129 different organs extracted from the scenarios of \CaseStudy{} are transplanted into 5 of the video game bosses that act as hosts, generating new video game bosses in the process. In total, our approach works with 645 transplants. To the best of our knowledge, our work has more transplants than previous work in the literature, with a maximum of 327 successful transplants~\cite{reid2020optimising}.
%We assess the quality of each generated boss by computing the duration of a match between the generated boss and a simulated player, a measurement that stems from the literature~\cite{browne2010evolutionary}. 

The results of the two Imhotep variants (Test-based and Simulation-based Imhotep) and a PCG baseline from the literature [14] are compared against an oracle (provided by developers). The results show that, out of the three approaches (the two Imhotep variants and the baseline), the content generated through the simulation-based Imhotep variant obtains the closest results to the oracle for all the generation scenarios (32\% better than the PCG baseline). The test-based Imhotep variant obtains the second place (25\% better than the PCG baseline), with the baseline obtaining worse results than the other two in all scenarios. The generated bosses are a promising starting point: developers can either include them directly in the game, modify them to better suit their needs, or inspect them to find novelties from which they can create more original designs.

Our contributions can be summarized as follows:
\begin{itemize}
    \item[\textbf{1}] Novel application of Software Transplantation on Procedural Content Generation (PCT approach),
    \item[\textbf{2}] Software Transplantation of software models in the field of video games development, and
    \item[\textbf{3}] Comparison of two objective functions based on the trends in Software Transplantation and on the trends in PCG.
\end{itemize}

The rest of the paper is structured as follows: Section~\ref{sec:Background} provides the research framework for our work. Section~\ref{sec:Approach} describes our approach, depicting its usage for PCG. Section~\ref{sec:Evaluation} details the evaluation of our approach. Section~\ref{sec:Results} highlights the results of our research. Section~\ref{sec:Discussion} discusses the outcomes of the paper and future lines of work. Section~\ref{sec:Threats} outlines the threats to the validity of our work. Section~\ref{sec:Related} reviews the works related to this one. Finally, 
Section~\ref{sec:Conclusion} concludes the paper by summarizing the main contributions and results.