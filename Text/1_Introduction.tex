\section{Introduction}

\IEEEPARstart{T}{he} video games industry grows significantly every year~\cite{rykala2020growth}. In 2019, the video games industry became the largest entertainment industry in terms of revenue after surpassing the combined revenues of the movie and music industries~\cite{politowski2021game}. In 2021, video games generated revenues of \$180.3 billion~\cite{wijman2021games}, and in 2022, the estimated revenues were of \$184.4 billion~\cite{wijman2022games}. Overall, the sum of revenues generated from 2020 to 2022 was almost \$43 billion higher than originally forecasted for the period. In 2019, out of a total population of 18.9M software developers, 8.8M developers were involved in video games development at some point~\cite{devData}, and by the end of 2022~\cite{devNation}, those who self-identified as software developers accounted for 24\% of all professional video game developers, which is a higher percentage than those who self-identified as game designers (23\%), artists (15\%), UI designers (8\%), or QA engineers (5\%) - roles that are typically identified by consumers as core roles for video games development.

Video games are complex creations where art and software go hand in hand during the development process to conform the final product. In a video game, software often permeates every aspect of the development, since it governs all the elements and actions that can appear or happen within the game. For instance, software controls aspects of a game as disparage as the position of enemies within the game, the selection of artistic elements for visual aspects of the game (such as textures, meshes, or character rigging), the logic behind the actions of NPCs\footnote{Non-playable characters which are not controlled by a player} within the game (often through state machines or decision trees), or the repercussions of such actions within the game. As video games become more and more advanced, their software also has to become more complex and diverse.

Software for video games can be implemented either through code or through software models. Developing a game through code enhances the control that developers have over the game. The downside to developing games through code is dealing with the implementation details. On the other hand, models elevate the abstraction level using domain concepts that are closer to its developers. Developing a game through modeling relieves the developers from the implementation details, and allows non-technical roles (such as level designers and artists) to participate in key aspects of the development. This competitive advantage over traditional code is a potential reason behind the recent increase in the popularity of modeling for developing video games: one of the most widespread video game development engines (Unreal Engine\footnote{https://www.unrealengine.com/}) provides a proprietary modeling language for development (Unreal Blueprints), and a recent survey in Model-Driven Game Development~\cite{zhu2019model} reveals that both UML and Domain Specific Language (DSL) models are also being adopted by development teams. The benefits of modeling present an opportunity for video game development teams to better cope with the growing complexity and demands of the software behind the games.

%The systematic reuse of previously generated content, or parts of it, in order to minimize bugs and cut development times is a very common occurrence within the video games industry~\cite{neto2009reuse}. However, manual reuse of content is typically frowned upon by the players: since developers tend to look at the components that they are most knowledgeable about for reuse, new content that is created from existing content tends to feel repetitive, unoriginal, and low-effort. This is especially true for video game content that has associated visual components (e.g. moving parts with reused animations).

One of such demands is the demand for content. With every passing day, the demand for video games content keeps growing, with players requesting - and more often than not, expecting - more content than developers can produce. Content generation (especially software generation) is a generally slow, tedious, costly, and error-prone manual process. In order to cope with the growing demand for novel, original content for video games, researchers are working towards procedural content generation. Procedural content generation (PCG) refers to the field of knowledge that aims at the automatic generation of new content within video games~\cite{hendrikx2013procedural}. To that extent, PCG has explored different techniques that Barriga \etal~\cite{Barriga2019} grouped in three categories: Traditional methods that generate content under a procedure without evaluation; Machine Learning methods that train models to generate new content; and Search-Based methods that generate content through a search on a predefined space guided by a meta-heuristic using one or more objective functions.

In this paper, we propose a new angle to tackle PCG for video games software inspired by transplantation techniques~\cite{barr2015automated}, that we named Procedural Content Transplantation (PCT). By definition, \textit{transplantation} is a procedure in which cells, tissues, or organs of an individual are replaced by those of another individual or the same person~\cite{FARSHBAFNADI2023599}. In software, we understand transplantation as a procedure in which a fragment (organ) of a software element (donor) is transferred into another software element (host). The transplantation core idea has been adapted to other research areas within the software research community such as program repair, testing, security, or functionality improvements.

Current PCG approaches work as follows: developers provide initial content (usually human-generated content) into an algorithm to work with. Afterwards, the algorithm (Traditional, Machine Learning, or Search-Based methods) will generate new content. Only a few traditional methods have succeeded in providing tools used by the industry to randomly generate vegetation (e.g., SpeedTree in Unreal and Unity). Our PCT proposal introduces the transplantation metaphor into this process. In our approach, the developers of a game will select an organ (from a donor) and a host that will receive the organ. The host and the organ will serve as inputs for a transplantation algorithm that will generate new software for the game combining them. Our hypothesis is that transplantation provides more control to developers (identifying host and organ), leading to results that are closer to their expectations.

Our PCT algorithm works with Search-Based Software Engineering. Search-Based Software Engineering has a better shot at exploring large search spaces than humans. In the state-of-the-art of software transplantation, the search evolves through genetic operations (crossover and mutation) and is guided by a test objective function. In the field of Search-Based Procedural Content Generation (SBPCG), the common practice is to guide the search through a simulation objective function. Taking into account the differences between both fields of research, we chose to leverage tests and simulations separately to guide the transplantation algorithm, and then compare the results obtained by the two objective functions.

Another difference between the state-of-the-art of software transplantation and SBPCG is the representation of the problem. Software transplantation works directly over the source code of a program, whereas due to the nature of video games, in SBPCG it is common to use software models to represent the content (more specifically, the links between the elements that conform the content) within the game. Since our approach aims to solve a problem in the field of SBPCG, we use software models for our representation.

Our approach, called Imhotep\footnote{Our approach is named after Imhotep, who is considered by many to have written the Edwin Smith papyrus (the oldest known manual of surgery).}, transplants software models through a search-based approach which uses crossover and mutation as genetic operations, and is guided by two objective functions (Test Suite and Simulation). The results of the two Imhotep variants (Test-based and Simulation-based Imhotep) are compared between them and against a PCG baseline from the literature~\cite{gallotta2022evolving}. We have carried out our evaluation over the \CaseStudy{} case study. \CaseStudy{} is a video game about flying and shooting with a spaceship in a three-dimensional space\footnote{See the official PlayStation trailer to learn more about \CaseStudy{}: \url{https://youtu.be/EhsejJBp8Go}}. The game was released on PC, PlayStation, and translated to eight different languages.

To evaluate Imhotep, 129 different organs extracted from the scenario of \CaseStudy{} are transplanted into 5 of the video game bosses that act as hosts, generating new video game bosses in the process. In total, our approach works with 645 transplants. We assess the quality of each generated boss by computing the duration of a match between the generated boss and a simulated player, a measurement that stems from the literature~\cite{browne2010evolutionary}. 

The results show that, out of the 3 objective functions, the content generated through game simulations obtains the best results for all the generation scenarios (that is, for the 5 bosses that act as hosts). The test-based fitness obtains the second place, with the baseline fitness obtaining worse results than the other two in all scenarios. The generated bosses are a promising starting point: developers can either include them directly in the game, modify them to better suit their needs, or inspect them to find novelties from which they can create more original designs. Overall, the quality and application opportunities of the obtained results encourage further research in the field.

Our contributions can be summarized as follows:
\begin{itemize}
    \item[\textbf{1}] Novel application of Software Transplantation on Procedural Content Generation (PCT approach),
    \item[\textbf{2}] Software Transplantation of software models in the field of video games development, and
    \item[\textbf{3}] Comparison of two objective functions based on the trends in Software Transplantation and on the trends in PCG.
\end{itemize}

The rest of the paper is structured as follows: Section~\ref{sec:Background} provides the research framework for our work. Section~\ref{sec:Approach} describes our approach, depicting its usage for PCG. Section~\ref{sec:Evaluation} details the evaluation of our approach. Section~\ref{sec:Results} highlights the results of our research. Section~\ref{sec:Discussion} discusses the outcomes of the paper and future lines of work. Section~\ref{sec:Threats} outlines the threats to the validity of our work. Section~\ref{sec:Related} reviews the works related to this one. Finally, Section~\ref{sec:Conclusion} concludes the paper by summarizing the main contributions and results.