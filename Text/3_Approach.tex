\section{Our Proposal: \ApproachName{} } 
\label{sec:Approach}
This section explains  how \ApproachName{}  makes use of evolutionary computation and software models to transplant organs within video games content in order to create new content (i.e., \CaseStudy bosses in our case study). To facilitate the comprehension, we also provide the reader with an example of transplantation for a simplified version of a  \CaseStudy  \sq{boss} inspired by the \sq{Serpent} boss shown in Figure.~\ref{fig:scenario} with letter B. Given the popularity of software models for video-game development (see Section \ref{sec:Background}),  we designed \ApproachName{}  to work with models. Although our running example uses the SDML models of \CaseStudy, our approach is generic and can be used with other modelling languages because it exploits the idea of boundaries between model elements.

Figure.~\ref{fig:approach} shows an overview of \ApproachName{}. At the top left there is the input to our approach, namely the organ to be transplanted from the donor and the host where the organ will be transplanted into. Afterwards, \ApproachName{} detects the points of the organ that allows the transplantation and the points where the organ can be inserted into the host. To initialize the population of the evolutionary algorithm, the organ is cloned and transplanted in a random point. Genetic operations generate potential solutions for transplantation, while the objective function asseses the quality of these solutions. This process of generating and assessing is repeated until a specific stop condition is met. When the evolutionary algorithm finishes the execution, we obtain a ranked list based on the given objective function of the best transplantations between organ and host. Next, we describe each step of \ApproachName{} in the following subsections.


\begin{figure}[tb]
    \centering
    \includegraphics[width=0.35\textwidth]{Figures/overview.png}
    \caption{Overview of  \ApproachName{}, our proposal for PCT.}
    \label{fig:approach}
\end{figure}


\subsection{Input selection}

\ApproachName{} allows the developers to identify a source model content (donor) with the organ that will be transplanted, and a target model content (host). 
In our running example we present a simplified version of the meta-model, and the corresponding concrete syntax of the model (see Figure.~\ref{fig:metamodel+syntax}) from  \CaseStudy{}.  In such model \sq{Hulls} serve as the structural framework that define the anatomical composition of the models. For example, the boss presented in Figure~\ref{fig:scenario} (identified as \sq{B}) has its body built by hulls. \sq{Weak points} are conceptual elements that possess the vulnerability to be harmed.
\sq{Weapons} are tangible items capable of causing harm through direct contact, such as discharging projectiles like bullets. Hulls, weak points, and weapons are attached between them through \sq{Links}.
%We use a graphical representation to help the comprehension of the reader, however the original metamodel does not work with a graphical model representation as it is not a requirement on every metamodel. The type of model will depend on the metamodel and models that developers decide on.

In our example, the source donor model is a simplified version of the original \CaseStudy{} \sq{boss} \sq{Serpent}. Figure ~\ref{fig:donor_host} (a) shows the graphical representation of the donor's model, differentiating each element of the model with a letter from A to S. It also shows with dashed lines the elements selected as organ (namely, H, I, J, K, N, O, P, Q). The host is a model of a regular enemy that could appear in \CaseStudy{}. Figure.~\ref{fig:donor_host} (b) shows the graphical representation of the host model.

\begin{figure}[tb]
	\centering
	\includegraphics[width=0.35\textwidth]{Figures/metamodel+syntax.png}
	\caption{Simplified meta-model and corresponding syntax.}
	\label{fig:metamodel+syntax}
\end{figure}

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.30\textwidth]{Figures/donor+host.png}
    \caption{(a) Donor model (with selected organ in dashed lines) and (b) host model.}
    \label{fig:donor_host}
\end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.2\textwidth]{Figures/host.png}
%     \caption{Host}
%     \label{fig:host}
% \end{figure}

\subsection{Boundary detection}
To transplant an organ into a host we need to find a way to connect them. To this end we exploit the boundaries between the model elements of the organ and the host. A boundary is a connection point capable of connecting two distinct model elements within a model. The connection is restricted by the rules of the metamodel. In the simplified example in Figure.~\ref{fig:metamodel+syntax}, the Source and Target meta-relationships are the boundaries between the model elements of the models conforming to that metamodel. In other model languages, there will be other meta-relationships with other names that will be the boundaries.

\ApproachName{} automatically identifies the boundaries of the selected organ, and all the boundaries of the host. In our running example, the boundaries of the organ are the connection points between donor and host. The elements that connect with the rest of the donor are H, K, and Q. Figure~\ref{fig:org_bound} (a) shows the donor and the selected organ with its boundaries (which are b11 for the H element; b16 for the K element, and b25 for the Q element). While, the host boundaries are all the points where its model elements connect. Figure~\ref{fig:org_bound} (b) shows all the boundaries of the host of our running example: The host has a total of 19 boundaries identified by a tag from ba to bs.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.45\textwidth]{Figures/donor+host+boundaries.png}
    \caption{(a) Donor  and (b) host model boundaries. The boundary is represented by a crossed circle.}
    \label{fig:org_bound}
\end{figure}

% \begin{figure}[h]
%     \centering
%     \includegraphics[width=0.35\textwidth]{Figures/host_boundaries.png}
%     \caption{Host model boundaries. The boundary is represented by a circle crossed.}
%     \label{fig:host_bound}
% \end{figure}

\subsection{Boundary mapping}
In the boundary mapping step, \ApproachName{} determines a mapping between the boundaries of the organ and the host. For each boundary in the organ, \ApproachName{} considers all compatible boundaries of the host, including the possibility of not connecting the boundary to the host boundaries. The boundary compatibility is determined by the metamodel.

Table~\ref{tab:boundaries} shows a boundary mapping between the organ and the host of the running example. The boundary b11 is a boundary from a \sq{Link} from the model and according to the metamodel it can connect to any \sq{Hull}, \sq{Weapon}, and \sq{Weak Point}. The boundaries b16 and b25 are both \sq{Hulls} and they can connect with any \sq{Link}.

\begin{table}[tb]
\centering
\resizebox{0.20\textwidth}{!}{
\begin{tabular}{|c|ll|}
\hline
{Organ boundaries} & \multicolumn{2}{c|}{{ \begin{tabular}[c]{@{}c@{}}Host \\      boundaries\end{tabular}}} \\ \hline
& \multicolumn{1}{c|}{ba} & \multicolumn{1}{c|}{bm} \\ \cline{2-3} 
& \multicolumn{1}{c|}{bd} & \multicolumn{1}{c|}{bp} \\ \cline{2-3} 
& \multicolumn{1}{c|}{bg} & \multicolumn{1}{c|}{bs} \\ \cline{2-3} 
\multirow{-4}{*}{b11} 
& \multicolumn{1}{c|}{bj} & \multicolumn{1}{c|}{Not connected} \\ \hline
& \multicolumn{1}{c|}{bb} & \multicolumn{1}{c|}{bc} \\ \cline{2-3} 
& \multicolumn{1}{c|}{be} & \multicolumn{1}{c|}{bf} \\ \cline{2-3} 
& \multicolumn{1}{c|}{bh} & \multicolumn{1}{c|}{bi} \\ \cline{2-3} 
& \multicolumn{1}{c|}{bk} & \multicolumn{1}{c|}{bl} \\ \cline{2-3} 
& \multicolumn{1}{c|}{bn} & \multicolumn{1}{c|}{bo} \\ \cline{2-3} 
\multirow{-6}{*}{\begin{tabular}[c]{@{}c@{}}b16\\    \\ b25\end{tabular}} 
& \multicolumn{2}{c|}{Not connected} \\ \hline
\end{tabular}}
\caption{Mapping of compatible organ-host boundaries.}
\label{tab:boundaries}
\end{table}

\subsection{Initialize population}
In evolutionary algorithms, a population is a collection of possible solutions for a problem. The encoding is the problem representation that an algorithm is capable to understand. 

In our work, the encoding requires a binary vector that represents the organ in the donor, and the boundary mapping (see Figure.~\ref{fig:encoding}). In the binary vector, each element from the model is a position in the vector. If a position in the vector has a \sq{1}, it means that the element from the model is part of the organ. On the other hand, each boundary from the organ gets assigned a compatible boundary from the host.
%In our work, each individual represents a software model from the game. We use a similar encoding version of Blasco \etal~\cite{blasco2021evolutionary} that has been adapted to work with transplantations. The size of the encoding in the previous work was 64 and in this work its size is of 150.
The initial population of \ApproachName{} contains individuals composed by the host and the organ placed in a random position (\ie a random mapping between the organ boundaries and the compatible organ boundaries).

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.35\textwidth]{Figures/encoding.png}
    \caption{Example of encoding.}
    \label{fig:encoding}
\end{figure}

\subsection{Genetic operators}
\ApproachName{} uses traditional genetic operators (namely, selection, crossover, and mutation) to generate new individuals (\ie candidate solutions). 
Specifically, we use the ranking selection, which ranks the individuals based on the objective function and retains the top ones in the current population. We use a single, random, cut-point crossover, which selects two parent solutions at random, and determines a cut point uniformly at random to split them into two sub-vectors. Then, the crossover creates two children solutions by combining the first part of the first parent with the second part of the second parent for the first child, and the first part of the second parent with the second part of the first parent for the second child. Finally, the new offspring is mutated by changing any value of the encoding uniformly at random with a certain probability. 
Figure~\ref{fig:candidates} shows an example of new individuals that could results from our running example. For simplicity, these individuals have unaltered organs, but illustrate different boundary mappings between organ and host.

\begin{figure}[tb]
    \centering
    \includegraphics[width=0.25\textwidth]{Figures/candidates.png}
    \caption{Example of individuals.}
    \label{fig:candidates}
\end{figure}

\subsection{Objective function}

Our work proposes to harness video games' NPCs to run simulations that provide data to assess the transplantations. The first thing that differentiates video games from traditional software is that the basic requirement of video games is \sq{fun}. \sq{Fun} is an abstract concept and the developers are in charge of interpreting it. In fact, different developers may have different interpretations. For some game developers, \sq{fun} is achieved with a difficult game that is very rewarding when progress is made (e.g., Dark Souls~\cite{darksouls}). While for other developers, \sq{fun} is achieved by effortlessly killing enemies (e.g., Dynasty Warriors~\cite{dynastywarriors}). Therefore, we argue that the developer intent is key for content generation.

Specifically, we propose to introduce the generated content (each individual in the population) into a simulation of the video game. The simulation produces a data trace of the events that have occurred. Using the data from the trace, we can check how well aligned are the events with the intention of the developers. In the running example, the simulation is a duel between a spaceship and a boss. The simulation generates data about the duel, such as the damage inflicted. The intention of the developers may be that the duel ends with the victory of the spaceship with a remaining life of less than 10\%.

Our proposal does not require ad hoc development of simulations. We propose that the simulations leverage mainly the NPCs (but also more video game elements, such as scenarios or items like weapons or powerups). NPCs are naturally developed during the development process of a video game. In other words, NPCs are integral components of  most video game genres such as First-Person Shooter (FPS), Real-Time Strategy (RTS), our racing games. We aim two goals with the aforementioned. On the one hand, it makes the use of simulations cheaper, i.e. it does not involve additional development costs, and secondly, it facilitates fidelity to the video game compared to ad hoc development. In the running example, during the simulation, the generated content is the boss, who can be accompanied by more NPCs acting as secondary enemies. Additionally, the spaceship that confronts the boss is an NPC representing an allied ship. Finally, the scenario, and items such as weapons or powerups also belong to the game itself.

In this work, the Simulation-based \ApproachName{} (\simhotep{}) assesses the transplants through a simulation of a game battle between the boss (Host') and a NPC spaceship. The information retrieved from the simulation is the data that the developers regard as relevant, using their domain knowledge. Hence, our approach takes into account  the percentage of simulated player victories ($F_{Victory}$) and the percentage of simulated player health left once the player wins a duel ($F_{Health}$).
The calculation of $F_{Victory}$ and $F_{Health}$ is performed in the same way as Blasco \etal~\cite{blasco2021evolutionary}, as described below:

$F_{Victory}$ is calculated as the difference between the number of human player victories ($V_{P}$) and the optimal number of victories (33\%, according to the developers of \CaseStudy{} and their criteria) ($V_{Optimal}$):
\begin{equation}
F_{Victory} = 1 -\frac{\mid V_{Optimal} - V_{P} \mid}{ V_{Optimal}}
\end{equation}

$F_{Health}$, which refers to completed duels that end in spaceship victories, is the average difference between the spaceship's health percentage once the duel is over ($\Theta_{P}$) and the optimal health level that the spaceship should have at that point ($\Theta_{Optimal}$, 20\%, according to the developers):
\begin{equation}
F_{Health} = 1 - \frac{\sum\limits_{d=1}^{V_{P}}\frac{\mid \Theta_{Optimal} - \Theta_{P} \mid}{ \Theta_{Optimal}}}{V_{P}}
\end{equation}

$F_{Overall}$ is an average objective value for a boss model that includes the objective criteria described above. $F_{Overall}$ also includes a validation part. The validation part is to avoid models with inconsistencies. The validity of the models is performed by a run-time interpreter that is part of the game. When the model is stated as non-valid the value of Validity will be 0. $F_{Overall}$ can assume a value in [0, 1] which is used to assess a boss model when our \ApproachName{} approach is applied to the \CaseStudy{} case study.

\begin{equation}
F_{Overall} = min \left ( Validity, \frac{\sum\limits_{i=1}^{N}F_{i}}{N} \right )
\end{equation}


% The objective function in \ApproachName{} assesses the quality of each individual as a model. First, as done in previous work that use \CaseStudy{}~\cite{blasco2021evolutionary}, the models pass through a validation process followed by a quantitative measurement. In our work we assess quantitatively the objective function by two means: Test-based and Simulation-based objective functions. We use two different objective functions due to the differences in the the state-of-the-art of software transplantation and PCG. The state-of-the-art in software transplantation mainly work with Test-based objective function, while the state-of-the-art in NPCs PCG work with Simulation-based objective function.

% The validation step before the Test-based or Simulation objective function is a requirement that \CaseStudy{} integrates in the game to avoid models with inconsistent data. The validity of the models is performed by a run-time interpreter that is part of the game. When the model is stated as non-valid the value of the objective function will be 0.0.

% The models that pass the validation process will then be assess by the Test-based and Simulation-based objective functions.
% For the Test-based objective function we ask the developers to provide the set of tests that they consider relevant to our work. The developers from \CaseStudy{} provided us with a total of 243 tests selected based on their domain knowledge. The objective value will be retrieved when each individual pass through the 243 tests, normalized in a scale of [0, 1]. An individual which passes the 243 tests will obtain 1.0, on the contrary if it does not pass any test it will obtain 0.0.

% On the other hand, the Simulation-based objective function as in Blasco \etal~\cite{blasco2021evolutionary} simulates an in game battle between the boss and a player. The information retrieved from the simulation is the data that the developers regard as relevant, using their domain knowledge. Hence, our approach takes into account the percentage of simulated player victories ($F_{Victory}$) and the percentage of simulated player health left once the player wins a duel ($F_{Health}$).
% The calculation of $F_{Victory}$ and $F_{Health}$ is performed in the same
% way as Blasco \etal~\cite{blasco2021evolutionary}:

% $F_{Victory}$ is calculated as the difference between the number of human player victories ($V_{P}$) and the optimal number of victories (33\%, according to the developers of \CaseStudy{} and their criteria) ($V_{Optimal}$):
% \begin{equation}
% F_{Victory} = 1 -\frac{\mid V_{Optimal} - V_{P} \mid}{ V_{Optimal}}
% \end{equation}

% $F_{Health}$, which refers to completed duels that end in human player victories, is the average difference between the human player's health percentage once the duel is over ($\Theta_{P}$) and the optimal health level that the player should have at that point ($\Theta_{Optimal}$, 20\%, according to the developers):
% \begin{equation}
% F_{Health} = 1 - \frac{\sum\limits_{d=1}^{V_{P}}\frac{\mid \Theta_{Optimal} - \Theta_{P} \mid}{ \Theta_{Optimal}}}{V_{P}}
% \end{equation}

% $F_{Overall}$ is an average fitness value for a boss model that includes the fitness criteria described above. $F_{Overall}$ can assume a value in [0, 1] which is used to assess a boss model when our \ApproachName{} approach is applied to the \CaseStudy{} case study.

% \begin{equation}
% F_{Overall} = min( Validity, \frac{\sum\limits_{i=1}^{N}F_{i}}{N} )
% \end{equation}
