\section{Background} \label{sec:Background}

\subsection{Model-driven video game development}

Video games are pieces of software that, like any other software, need to be designed, developed, and maintained over time. However, there are some particularities of video games that make them differ from traditional software, such as the artistic component of the videogame, the complexity of the rendering pipelines, the heterogeneous nature of video game development teams, and the abstract nature of the final purpose of a video game: fun. 

Hence, video games present characteristics that differentiate their development and maintenance from the development and maintenance of classic software. Examples of these differences can be found in how video game developers must contribute to the implementation of different kinds of artifacts (e.g., shaders, meshes, or prefabs) or in the challenges they face when locating bugs or reusing code for the video game~\cite{pascarella2018video, chueca2023consolidation}.

Nowadays, most video games are developed by means of game engines. Game engines are development environments that integrate a graphics engine and a physics engine as well as tools for both to accelerate development. The most popular ones are Unity and Unreal Engine, but it is also possible for a studio to make its own specific engine (e.g., CryEngine~\footnote{\url{https://www.cryengine.com}}). 

One key artifact of game engines are software models. Unreal proposes its own modeling language (Unreal Blueprints), and a recent survey in Model-Driven Game Development~\cite{zhu2019model} reveals that UML and Domain Specific Language (DSL) models are also being adopted by development teams. Developers can use the software models to create video game content instead of using the traditional coding approach. While code allows for more control over the content, software models raise the abstraction level, promoting the use of domain terms and minimizing implementation and technological details. Through software models, developers are freed from a significant part of the implementation details of physics and graphics, and can focus on the content of the game itself (see Fig.~\ref{fig:architecture}).

\begin{figure}[h]
    \centering
    \includegraphics[width=0.45\textwidth]{Figures/fig_bg_OverviewArtifactsVG.pdf}
    \caption{Overview of video game artifacts.}
    \label{fig:architecture}
\end{figure}

\subsection{\CaseStudy{}}

The research presented in this paper is framed within the context of a commercial video game case study, \CaseStudy{}. In particular, our evaluation uses the bosses of the video game to evaluate the approach. Each level of \CaseStudy{} consists of a three-dimensional space where a player-controlled spaceship has to fly from a starting point to a target destination, reaching the goal before being destroyed. The gameplay experience involves exploring floating structures, avoiding asteroids, and finding items along the route, while basic enemies try to damage the spaceship by firing projectiles. If the player manages to reach the destination, the final boss corresponding to that level appears and must be defeated in order to complete the level. 

Bosses can be built either using C++ code or software models. The top part of Figure~\ref{fig:scenario} depicts a boss fight scenario where the player-controlled ship (item A in the figure) is battling The Serpent (item B in the figure), which is the final boss that must defeated in order to complete Level 1. The bottom part of the figure illustrates the two possible development approaches for the boss.

\begin{figure}[h]
    \centering
    \includegraphics[width=\columnwidth]{Figures/MM_Scenario.pdf}
    \caption{Model-Driven Development vs. Code-Centric Development in the context of \CaseStudy{}}
    \label{fig:scenario}
\end{figure}

Even though Figure~\ref{fig:scenario} shows excerpts of the implementation of The Serpent both in the form of software models and code, it is not necessary to implement the two simultaneously. Although developers can mix both technologies, developing different parts of the boss using one or the other indistinctly, they are also free to implement the content using software models exclusively or to do so purely via code. However, the heterogeneous nature of video game development teams - comprised majorly of programmers~\cite{devNation}, but also counting game designers, artists, UI designers, and QA engineers within their ranks - possibly favours the use of software models over code, since the higher abstraction level of the former (combined with their detachment from more technical implementation details) empowers less tech-focused roles to embrace a more active participation in development tasks. Furthermore, an experiment~\cite{domingo2020evaluating} confirmed that video game developers make fewer mistakes and are more efficient when working with the models than with the code.

Within the context of \CaseStudy{}, the elements of the game are created through software models, and more specifically, through the Shooter Definition Model Language (SDML). SDML is a DSL model for the video game domain that defines aspects that are included in video game entities: the anatomical structure (including their components, physical properties, and connections); the amount and distribution of vulnerable parts, weapons, and defenses; and the movement behaviours associated to the whole body or its parts. SDML has concepts such as hulls, links, weak points, weapons, and AI components, and allows for the development of any game element, such as bosses, enemies, or environmental elements. The models are created using SDML and interpreted at runtime to generate the corresponding game entities. In other words, software models created using SDML are translated into C++ objects at runtime using an interpreter integrated into the game engine~\cite{blasco2021evolutionary}. More information on the SDML model can be found in the following video presentation: \url{https://youtu.be/Vp3Zt4qXkoY}.

